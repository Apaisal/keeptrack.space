// Generated by CodiumAI

import { EciArr3, SatObject } from '@app/interfaces';
import { CoordinateTransforms } from '@app/static/coordinate-transforms';
import { Degrees, EciVec3, Kilometers, Radians } from 'ootk';
import { defaultSensor } from './environment/apiMocks';

/**
Main functionalities:
The CoordinateTransforms class provides static methods for converting between different coordinate systems used in satellite tracking. It includes methods for converting satellite position and velocity vectors from ECI to RIC reference frame, converting RAE (Right Ascension, Azimuth, Elevation) coordinates to ECEF (Earth-Centered, Earth-Fixed) coordinates, converting ECI coordinates to latitude, longitude and altitude, and converting ECI coordinates to RAE coordinates.

Methods:
- sat2ric(sat: SatObject, reference: SatObject): Converts satellite position and velocity vectors from ECI to RIC reference frame.
- rae2ecf(az: Degrees, el: Degrees, rng: Kilometers, lat: Radians, lon: Radians, alt: Kilometers): Converts RAE coordinates to ECEF coordinates.
- eci2lla(position: EciVec3, simulationTime: Date): Converts ECI coordinates to latitude, longitude and altitude.
- eci2rae(now: Date, eci: EciArr3, sensor: SensorObject): Converts ECI coordinates to RAE coordinates.

Fields:
- None.
 */

describe('CoordinateTransforms_class', () => {
  // Tests that sat2ric method returns correct RIC coordinates for valid input
  it('test_sat2ric_valid_input', () => {
    const sat = {
      position: { x: 1000, y: 2000, z: 3000 },
      velocity: { x: 7, y: 0, z: 0 },
    };
    const reference = {
      position: { x: -1000, y: -2000, z: -3000 },
      velocity: { x: 7, y: 0, z: 0 },
    };

    const result = CoordinateTransforms.sat2ric(sat as SatObject, reference as SatObject);

    expect(result).toMatchSnapshot();
  });

  // Tests that rae2ecf method returns correct ECEF coordinates for valid input
  it('test_rae2ecf_valid_input', () => {
    const az = 45 as Degrees;
    const el = 30 as Degrees;
    const rng = 1000 as Kilometers;
    const lat = 0.7853981633974483 as Radians;
    const lon = -1.5707963267948966 as Radians;
    const alt = 0 as Kilometers;
    const result = CoordinateTransforms.rae2ecf(az, el, rng, lat, lon, alt);
    expect(result).toMatchSnapshot();
  });

  // Tests that eci2lla method returns correct LLA coordinates for valid input and simulation time
  it('test_eci2lla_valid_input', () => {
    const position = { x: -445.041, y: -445.041, z: 707.106 } as EciVec3;
    const simulationTime = new Date('2021-01-01T00:00:00Z');
    const result = CoordinateTransforms.eci2lla(position, simulationTime);

    expect(result).toMatchSnapshot();
  });

  // Tests that sat2ric method throws an error for null input
  it('test_sat2ric_null_input', () => {
    const sat = null;
    const reference = null;
    expect(() => CoordinateTransforms.sat2ric(sat, reference)).toThrow();
  });

  // Tests that rae2ecf method throws an error for negative range
  it('test_rae2ecf_negative_range', () => {
    const az = 45 as Degrees;
    const el = 30 as Degrees;
    const rng = -1000 as Kilometers;
    const lat = 0.7853981633974483 as Radians;
    const lon = -1.5707963267948966 as Radians;
    const alt = 0 as Kilometers;
    expect(() => CoordinateTransforms.rae2ecf(az, el, rng, lat, lon, alt)).toThrow();
  });

  // Tests that eci2lla method throws an error for invalid input and simulation time
  it('test_eci2lla_invalid_input', () => {
    const position = null;
    const simulationTime = null;
    expect(() => CoordinateTransforms.eci2lla(position, simulationTime)).toThrow();
  });

  it('test_valid_input_with_observerGd_and_positionEcf', () => {
    const now = new Date();
    const eci = [1000, 2000, 3000] as EciArr3;
    const sensor = defaultSensor;
    const result = CoordinateTransforms.eci2rae(now, eci, sensor);
    expect(result).toMatchSnapshot();
  });
});
